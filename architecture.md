# Требования

По хорошему, Mock-Server в итоге должен уметь в 4 концепта:

- Создавать mock для REST-API
  - Возвращать константный ответ, по предикату
  - Запускать простой обработчик, например на Python. Можно использовать идею из MapReduce: пользователь описывает одну функцию и её аргументы на Python и может в последстивии запустить её, передав в теле запроса конкретные значения аргументов

- Создавать mock для очередей сообщений
  - Создавать новую очередь в брокере сообщений и начинать считывать все сообщения, пришедшие в эту очередь

- Связывать 2 очереди логикой преобразования ответов(ESB)
  - Создать воркера, который бы брал, все что прочли из IN очереди и, пропуская через mapper, отправлял ответ в очередь OUT

- Проксировать HTTP запросы пользователя к реальным сервисам, которые ранее были замокированы

# Архитектура

![arch](docs/architecture_overview.png)

## Frontend

Используем [React + Axios](https://www.digitalocean.com/community/tutorials/react-axios-react) для отрисовки сайта и вызова ручек бекенда, пример использования Axios:

```js
const user = {
    name: this.state.name
};

axios.post(`https://jsonplaceholder.typicode.com/users`, { user })
    .then(res => {
        console.log(res);
        console.log(res.data);
    }
)
```

Вроде как неплохой фреймворк для создания async web проксей, что нам тут и нужно

## Backend

### Общая часть

Backend полностью будет написан на языке Golang, в качестве основного web фреймворка будем использовать библиотеку [gin](https://github.com/gin-gonic/gin)

Запросы от фронтенда делятся на категории:

- `http://domain/ui/...` UI запросы, которые в основном будут нужны, чтобы доставать информацию для рендера сайта, как например, список существующих REST моков.

- `http://domain/internal/...` Внутренние запросы. С их помощью будет реализовывана логика авторизации, аутентификации, создания моков и тд.

- `http://domain/proxy/...` Такие запросы просто будут проксироваться в backend, в основном это будут запросы к мокированным ручкам.

---

### База данных

В качестве базы данных мы выбрали mongodb, так как в ней, без особых усилий, можно хранить raw данные, например формата JSON.

В процессе работы придется хранить информацию о зарегистрированных пользователях, информацию о существующих мокированных маршрутах и прослушиваемых очередях, а также сообщения, прочитанные из очередей, для отрисовки в UI.

Будет как минимум 4 коллекции в Mongo:
- Users
- handles
- message_queues
- messages

---

### Работа с Брокерами сообщений | Чтение

Нужно в один моменте слушать N очередей с разных брокеров. Чтобы это выполнять эффективно, при старте сервера заведем пул горутин, которые будут держать активные сессии с каждым из брокеров.

![block_queue](docs/blocking_queue.png)

Создадим канал, в котором будут распределяться очереди. После того как горутина захватила очередь для чтения, она перестраивает сессию с брокером, чтобы читать именно с этой очереди, после чего читает несколько секунд и скидывет эту очередь опять в канал.

При таком подходе у нас фиксированное кол-во tcp соединений с брокерами, меняется лишь то, с каких очередей мы читаем.

### Работа с Брокерами сообщений | Запись

Чтобы писать в очереди, также как в предыдущем пункте создадим пул горутин и связывающий их канал, в который будут попадать задачи записи в определенную очередь.

---

### Rest mock

Хочется поддержать 2 вида мокирования Rest API:

- `Статический ответ` - На любое дергание ручки будем отдавать заранее фиксированный ответ

- `Динамический ответ` - При создании такого мока пользователю будет необходимо написать программу на Python, в которой будет нужно определить лишь одну функцию `handler`, аргументом которой будет 2 dict-а - body и headers запроса

Чтобы поддержать Статический ответ, будем просто отдавать его в ответ на дергание ручки. Контент ответа сохраняется в базе данных.

Чтобы поддержать Динамический ответ, при получении тела с аргументами функции, подставим их в функцию пользователя, обернём её в программу, которую запускатим в отдельном процессе, чтобы гарантировать ограниченное окружение запуска. Код пользовательских программ также будет хранится в базе данных.

---

### Proxy

Последнее, что нужно реализовать - проксирование запроса в реальный сервис. Это позволит при разработке частей системы тестировать их через mock, а после релиза переключать трафик на реальный сервис, тем самым облегчая процесс деплоя и тестирования сервиса.

Чтобы поддержать эту возможность, нужно просто сделать 2 пайпа:

- User -> Real
- Real -> User

Каждую из этих пайп можно делать поднятием временной горутины, которая просто транслирует потоки друг в друга.
